# simd vectors

* Proposal: [SE-0000](0000-simd.md)
* Authors: [Stephen Canon](https://github.com/stephentyrone)
* Review Manager: TBD
* Status: **Awaiting Review**

## Introduction

This proposal would expose a common subset of operations on the SIMD types supported
by most processors in the standard library. It is based on Apple's <simd/simd.h> module,
which is used throughout Apple's platforms as the common currency type for fixed-size 
vectors and matrices. It is not a complete re-implementation; rather it provides the low-level
support needed to import any such library, and tries to make a number of things much nicer 
in Swift than they are in C or C++.

Preliminary Swift-evolution [discussion](https://forums.swift.org/t/simd-vector-types/16254/).

## Motivation

### Task 1: SIMD programming 
Essentially every modern CPU has support for [SIMD](https://en.wikipedia.org/wiki/SIMD)
("Single Instruction, Multiple Data") instructions in hardware. Without getting into a long
discussion of the architectural details, effective use of these instructions allows 2-10x better
performance than is otherwise possible for a large class of data-parallel problems, without 
incurring the synchronization and data-movement hassles of working with the GPU.

Historically, there have been a number of obstactles to taking advantage of this hardware.
Four programming models have been commonly used, all of which the author has considerable
experience with:
- Assembly: this has the advantage that you get exactly the code you want. It has numerous
disadvantages--another language to learn, requiring either macro soup or separate
implementations for every target (in effectively a different language for each), there are few
good learning resources, and you have to slog through all the tedious things that the compiler 
normally does for you, like allocating registers and getting the calling conventions right (or
wrong, in subtle ways that bite your users many years later).
- Intrinsics: The model historically pushed by hardware vendors. Each architecture has its own
set of C "intrinsic" types like `__m128` (x86) or `int8x8_t` (ARM). These are superficially nicer
than assembly, but in practice incur nearly all of the downsides, plus a few additional ones.
The biggest problem is that these types are often bolted awkwardly onto the language, and
so are incompatible with fundamental language or runtime assumptions about size or 
alignment. Innumerable bugs have been created by people attempting to use vector intrinsic
types together with C++ containters, for example. These types move your implementation into
a portable language (C or C++), and then immediately remove that portability by being tied to
a specific architecture.
- "Vector class" libraries: Agner's is the most well-known. What these generally bring to the
table is support for familiar operators rather than arcane intrinsics (e.g. `a + b` instead of 
`_mm_addps(a, b)`). Most are narrowly focused on a single architecture (almost always x86,
so they still don't provide real portability). Apple's <simd/simd.h> is similar to these, but with
full support for every architecture that Apple uses, which in practice makes code written
against it fairly portable.
- Autovectorization: works well for simple problems, but no one has yet demonstrated a
satisfactory solution for more general tasks. One of several problems is that the underlying
machine model assumed by vector code is fundamentally distinct from the underlying
machine model that most scalar code is written against, forcing an autovectorizing compiler
to map between the two. Historically this was largely done via an ad-hoc set of 
transformations, which never really worked all that well. Newer approaches show some
promise, but explicit manual vectorization is still frequently needed.

A major goal of these new data types in Swift is to provide a *better* API for vector
programming. We want to capture the cross-platform nicities of the <simd/simd.h> module,
but also add some new features that were difficult or impossible to do in C; things like enabling
generic programming, but also things as simple as a native way to express vector permutations
and unaligned loads, or even just conversions between different vector types with the same
number of elements (this requires a function call rather than a cast with most vector libraries).

Looking ahead, I expect that we will use these primitives to expose things like iterating over
vectors extracted from a collection of scalars, to make explicitly vectorized code much more
approchable.

### Task 2: geometry primitives
There is a large class of computational tasks (graphics and animation, image processing,
AR, VR, computer vision) that want to have 2, 3, and 4 dimensional vector and matrix types.
For these applications, these types are just as fundamental as `Int` and `Array` are for 
"normal" programming--they are the foundation upon which everything else is constructed.

These tasks require both elementwise operations, as well as some operations on types as
abstract vectors--things like the dot and cross products, vector length, and orientation tests.

### Task 3: GPU data structures
Closely related to part 2, short vectors are also essential data types for representing GPU data
structures. It's frequently necessary to handle these on the CPU side do do pre/post
processing, or data marshalling, and exposing these types in Swift enables that task.

### Putting it together
Superficially, the only thing that these tasks have in common is that the fundamental types
are "homogeneous aggregates", and that they want to benefit from the SIMD hardware that is
available. Two or even three sets of types may seem more appropriate. However, our
experience with clients of <simd/simd.h> is that all of our clients use a diverse subset of
operations from the module, and that it's difficult to draw clear boundaries of what belongs
where. While it may be reasonable to refine the underlying *protocols*, the types should
probably remain unified.

Looking ahead, we would like to enable more sophisticated storage layouts and transforms
to and from them, such as SoA - AoS conversion (a fancy way of saying "matrix transpose" or
"interleave / deinterleave"; these are all the same thing). Once you start thinking about such
transforms, the distinction between these types really goes out the window, because you want
to map between things like 16 vectors of 3 floats and 3 vectors of 16 floats.

## Proposed solution

We propose to add the following types to the standard library:

## Detailed design

Describe the design of the solution in detail. If it involves new
syntax in the language, show the additions and changes to the Swift
grammar. If it's a new API, show the full API and its documentation
comments detailing what it does. The detail in this section should be
sufficient for someone who is *not* one of the authors to be able to
reasonably implement the feature.

## Source compatibility

No source compatibility changes.

## Effect on ABI stability

No effects on ABI stability at the language level. There are some minor changes around
how the <simd/simd.h> types are imported on Apple platforms, but these will have no effect
on source compatibility; they only may tweak some low-level ABI details.

## Effect on API resilience

Because these are entirely new types, they come with a large set of API that will become part
of the standard library interface. New API can be added in the future, including to protocols,
because it is generally possible to provide good default implementations for simd operations.

## Alternatives considered

The main alternative is "don't do anything, let people write structs, and trust the autovectorizer."
This might even mostly work, but even if it worked flawlessly (which it doesn't today), you
would be left with the problem that these types are common, and everyone would be using
their own set of structs, with slightly incompatible size and alignment or operations provided.
Even when the layout matches up, you would still need to provide conversion shims between
each and every library you work with. There is a lot of merit in providing a single ground-truth
for low-level vectors in the stdlib, over which libraries and programs can build additional
operations.

During the pitch phase, almost all discussion was focused on the spelling of the type names.
There are three basic suggestions, with some passionate supporters of each:

- `Float.Vector8` (this proposal). 

- `Vector8<Float>` This has the virtue of leveraging the usual Swift syntax for generics, and
arguably looking "swiftier" because of it. The downside is that although it uses the *syntax*, it
doesn't benefit from most of the *semantics* of generics in the language, because we need to
specialize the layout (using llvm builtin vectors) for each type/vector size to benefit from explicit
vectorization. Because of this, it is somewhat more complex--every operation in effect ends up
going through an extra layer of abstraction. With judicious use of `@inlinable` and 
`@_transparent`, this should not have any performance consequences, but in my opinion it
compromises understandability, and is a layer of complexity that we don't need.

 Another argument for this convention is that it may help discoverability; if I see
 `Vector8<Float>`, I might decide to try `Vector8<Int8>` too. On the downside, we want to
 cap the maximum vector size at 64B; doing this with this naming scheme is somewhat
 complicated, and involves adding a bunch of protocols for specifying element size, or else
 you can't constrain people from doing `Vector64<Int64>`.

- `Vector8.Float` This is an attempt to mirror the "desired" `Vector8<Float>` syntax
while avoiding the extra boilerplate. The downside to this convention is that there isn't a nice
way straight out of the box to go from element type to a vector type, so you need a parallel
set of typenames or protocols to enable that fairly desireable operation for generic
programming.

Both the second and third option also add new members to the top-level namespace, while
the first does not. Especially in light of the fact that we may someday be able to build 
something like `Vector<Float, 8>`, which I find consdierably more desireable, avoiding
adding anything to that namespace for now seems to me to be the right decision.
